{"version":3,"sources":["../src/authorize.js"],"names":["authorize","credentials","callback","clientSecret","installed","client_secret","clientId","client_id","redirectUrl","redirect_uris","auth","googleAuth","oauth2Client","OAuth2","readFile","TOKEN_PATH","err","token","getNewToken","JSON","parse","authUrl","generateAuthUrl","access_type","scope","SCOPES","console","log","rl","readline","createInterface","input","process","stdin","output","stdout","question","code","close","getToken","storeToken","mkdirSync","TOKEN_DIR","writeFile","stringify"],"mappings":";;;;;;;;;AASwBA,S,CARxB,wB,qIACA;;;;;;0KAOe,SAASA,SAAT,CAAmBC,WAAnB,EAAgCC,QAAhC,EAA0C,CACxD,IAAIC,eAAeF,YAAYG,SAAZ,CAAsBC,aAAzC,CACA,IAAIC,WAAWL,YAAYG,SAAZ,CAAsBG,SAArC,CACA,IAAIC,cAAcP,YAAYG,SAAZ,CAAsBK,aAAtB,CAAoC,CAApC,CAAlB,CACA,IAAIC,OAAO,IAAIC,UAAJ,EAAX,CACA,IAAIC,eAAe,IAAIF,KAAKG,MAAT,CAAgBP,QAAhB,EAA0BH,YAA1B,EAAwCK,WAAxC,CAAnB;AAEA;AACA,cAAGM,QAAH,CAAYC,UAAZ,EAAwB,UAAUC,GAAV,EAAeC,KAAf,EAAsB;AAC7C,MAAID,GAAJ,EAAS;AACRE,eAAYN,YAAZ,EAA0BV,QAA1B;AACA,GAFD,MAEO;AACNU,gBAAaX,WAAb,GAA2BkB,KAAKC,KAAL,CAAWH,KAAX,CAA3B;AACAf,YAASU,YAAT;AACA;AACD,EAPD;AAQA;;AAED;;;;;;;MA3BA;AAmCA,SAASM,WAAT,CAAqBN,YAArB,EAAmCV,QAAnC,EAA6C;AAC5C,KAAImB,UAAUT,aAAaU,eAAb,CAA6B;AAC1CC,eAAa,SAD6B;AAE1CC,SAAOC,MAFmC,EAA7B,CAAd;;AAIAC,SAAQC,GAAR,CAAY,2CAAZ,EAAyDN,OAAzD;AACA,KAAIO,KAAKC,SAASC,eAAT,CAAyB;AACjCC,SAAOC,QAAQC,KADkB;AAEjCC,UAAQF,QAAQG,MAFiB,EAAzB,CAAT;;AAIAP,IAAGQ,QAAH,CAAY,sCAAZ,EAAoD,UAAUC,IAAV,EAAgB;AACnET,KAAGU,KAAH;AACA1B,eAAa2B,QAAb,CAAsBF,IAAtB,EAA4B,UAAUrB,GAAV,EAAeC,KAAf,EAAsB;AACjD,OAAID,GAAJ,EAAS;AACRU,YAAQC,GAAR,CAAY,6CAAZ,EAA2DX,GAA3D;AACA;AACA;AACDJ,gBAAaX,WAAb,GAA2BgB,KAA3B;AACAuB,cAAWvB,KAAX;AACAf,YAASU,YAAT;AACA,GARD;AASA,EAXD;AAYA;;AAED;;;;;AAKA,SAAS4B,UAAT,CAAoBvB,KAApB,EAA2B;AAC1B,KAAI;AACH,eAAGwB,SAAH,CAAaC,SAAb;AACA,EAFD,CAEE,OAAO1B,GAAP,EAAY;AACb,MAAIA,IAAIqB,IAAJ,IAAY,QAAhB,EAA0B;AACzB,SAAMrB,GAAN;AACA;AACD;AACD,cAAG2B,SAAH,CAAa5B,UAAb,EAAyBI,KAAKyB,SAAL,CAAe3B,KAAf,CAAzB;AACAS,SAAQC,GAAR,CAAY,qBAAqBZ,UAAjC;AACA","file":"authorize.js","sourcesContent":["/*eslint no-console: [\"error\", { allow: [\"warn\", \"error\", \"log\"] }] */\nimport fs from 'fs'\n/**\n * Create an OAuth2 client with the given credentials, and then execute the\n * given callback function.\n *\n * @param {Object} credentials The authorization client credentials.\n * @param {function} callback The callback to call with the authorized client.\n */\nexport default function authorize(credentials, callback) {\n\tlet clientSecret = credentials.installed.client_secret\n\tlet clientId = credentials.installed.client_id\n\tlet redirectUrl = credentials.installed.redirect_uris[0]\n\tlet auth = new googleAuth()\n\tlet oauth2Client = new auth.OAuth2(clientId, clientSecret, redirectUrl)\n\n\t// Check if we have previously stored a token.\n\tfs.readFile(TOKEN_PATH, function (err, token) {\n\t\tif (err) {\n\t\t\tgetNewToken(oauth2Client, callback)\n\t\t} else {\n\t\t\toauth2Client.credentials = JSON.parse(token)\n\t\t\tcallback(oauth2Client)\n\t\t}\n\t})\n}\n\n/**\n * Get and store new token after prompting for user authorization, and then\n * execute the given callback with the authorized OAuth2 client.\n *\n * @param {google.auth.OAuth2} oauth2Client The OAuth2 client to get token for.\n * @param {getEventsCallback} callback The callback to call with the authorized\n *     client.\n */\nfunction getNewToken(oauth2Client, callback) {\n\tvar authUrl = oauth2Client.generateAuthUrl({\n\t\taccess_type: 'offline',\n\t\tscope: SCOPES\n\t})\n\tconsole.log('Authorize this app by visiting this url: ', authUrl)\n\tvar rl = readline.createInterface({\n\t\tinput: process.stdin,\n\t\toutput: process.stdout\n\t})\n\trl.question('Enter the code from that page here: ', function (code) {\n\t\trl.close()\n\t\toauth2Client.getToken(code, function (err, token) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log('Error while trying to retrieve access token', err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\toauth2Client.credentials = token\n\t\t\tstoreToken(token)\n\t\t\tcallback(oauth2Client)\n\t\t})\n\t})\n}\n\n/**\n * Store token to disk be used in later program executions.\n *\n * @param {Object} token The token to store to disk.\n */\nfunction storeToken(token) {\n\ttry {\n\t\tfs.mkdirSync(TOKEN_DIR)\n\t} catch (err) {\n\t\tif (err.code != 'EEXIST') {\n\t\t\tthrow err\n\t\t}\n\t}\n\tfs.writeFile(TOKEN_PATH, JSON.stringify(token))\n\tconsole.log('Token stored to ' + TOKEN_PATH)\n}"]}